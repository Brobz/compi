// NucaScript VM
// To compile: g++ -std=c++11 -o out_file_path


#include <iostream>
#include <fstream>
#include <stack>
#include <ctime>

#include "MemoryContext.h"
#include "Value.h"
#include "FileIO.h"
#include "OPCodes.h"
#include "Utils.h" // NOTE: This include statement is bound to fail without a proper intermediate object-code file
				   //		Such a file will be automatically generated by the NucaScript Compiler
				   //		The NucaScript VM is only to be instantiatied via the Compiler code, and not directly

using namespace std;

// Does all of the needed initializations so that the program can be run
void setup(){

	// Memory signature with highest value is always pointing to the start of the main() method (no function can syntactically come after the main)
  	PROGRAM_START = FUNCTION_MEMORY_CONTEXT_SIGN.rbegin()->first;

  	// Generates global memory context
  	GLOBAL_MEM = MemoryContext(FUNCTION_MEMORY_CONTEXT_SIGN.at(PROGRAM_START).at(0), FUNCTION_MEMORY_CONTEXT_SIGN.at(PROGRAM_START).at(1), FUNCTION_MEMORY_CONTEXT_SIGN.at(PROGRAM_START).at(2));

	// WRITE CONSTANTS TO MEMORY //

	for (auto const& pair : CONSTANTS){
		write_to_memory(pair.first, pair.second);
  	}

	// SEED THE PSEUDORANDOM GENERATOR //

	srand(time(NULL));

	// SET INITIAL VALUES FOR GLOBAL VARS //

	RUNNING = true; // This will get the instruction pointer movin through the quads
  	IP = 0; // Start execution at the first QUAD
	THIS_OPERATOR_COUNTER = 0; // No this.have been seen yet
	LOCAL_MEM = new MemoryContext(); // Initialize LOCAL_MEM without parameters so that LOCAL_MEM->active is set to false
	THIS_MEM = new Memory();
}

// Runs the program, starting from QUAD 0
void run(){
  while(RUNNING){
	  int op = QUADS[IP][0];

	  if (op == SINGLE_EQUALS)
	  {
		  int is_ptr = QUADS[IP][1];
		  int result_addr;
		  Value value;

		  if (is_ptr == 1 || is_ptr == 3)
			  value = read_from_memory(read_from_memory(QUADS[IP][2]).i);
		  else
			  value = read_from_memory(QUADS[IP][2]);

		  if (is_ptr == 2 || is_ptr == 3)
			  result_addr = read_from_memory(QUADS[IP][3]).i;
		  else
			  result_addr = QUADS[IP][3];

		  write_to_memory(result_addr, value.to_str());

		  IP++;
		  continue;
		}

		else if (op <= 13){
			// Arithmetic Epxressions (unary and binary)

			int result_addr = QUADS[IP][3];

			Value left_value, right_value;

			// May be a unary expression
			if (QUADS[IP][1] >= 0){
				left_value = read_from_memory(QUADS[IP][1]);
			}

			right_value = read_from_memory(QUADS[IP][2]);

			switch (op) {
				case PLUS:
					{
						// Sum!
						Value res_value = left_value + right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case MINUS:
					{
						Value res_value;
						if (left_value.has_value())
							// Subtract !
							res_value = left_value - right_value;
						else
							// Negate !
							res_value = -right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case MULT:
					{
						// Mutiply!
						Value res_value = left_value * right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case DIV:
					{
						// Divide!
						Value res_value = left_value / right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case DOUBLE_EQUALS:
					{
						// Compare (equals to)!
						Value res_value = left_value == right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case GREATER_THAN:
					{
						// Compare (bigger than)!
						Value res_value = left_value > right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case LESSER_THAN:
					{
						// Compare (less than)!
						Value res_value = left_value < right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case GREATER_THAN_OR_EQ_TO:
					{
						// Compare (bigger than or equal to)!
						Value res_value = left_value >= right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case LESSER_THAN_OR_EQ_TO:
					{
						// Compare (less than or equal to)!
						Value res_value = left_value <= right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case AND:
					{
						// Compare (and)!
						Value res_value = left_value && right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case OR:
					{
						// Compare (or)!
						Value res_value = left_value || right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;

				case NOT_EQUAL_TO:
					{
						// Compare (not equal to)!
						Value res_value = !(left_value == right_value);
						write_to_memory(result_addr, res_value.to_str());
					}
					break;
				case NOT:
					{
						// Negate!
						Value res_value = !right_value;
						write_to_memory(result_addr, res_value.to_str());
					}
					break;
			}
			IP++;
			continue;
		}

    switch(op) {
			// Other operations

			case ARR_ACCESS:
        {
					int result_addr = QUADS[IP][3];

					int arr_addr = QUADS[IP][1];
					int access_value = read_from_memory(QUADS[IP][2]).i;

					int result = arr_addr + access_value;

					write_to_memory(result_addr, to_string(result));
					IP++;
        }
        break;

			case ARR_BNDS:
        {
					Value arr_access_value = read_from_memory(QUADS[IP][2]);
					int arr_dim_size = QUADS[IP][3];

					if (arr_access_value.i < 0 || arr_access_value.i >= arr_dim_size){
						// If this point is reached, an array index out of bounds error has ocurred
						cout << ">> Fatal Error: array index out of bounds!" << endl;
						exit(EXIT_FAILURE);
					}

					// Else, continue execution
					IP++;
        }
        break;

			case TMP_RESET:
        {

					int reset_value = QUADS[IP][2];
					int tmp_address = QUADS[IP][3];

					write_to_memory(tmp_address, to_string(reset_value));

					IP++;
        }

        break;

			case USNG_AS:
        {

					int arr_size = QUADS[IP][1];
					int class_sign = QUADS[IP][2];
					int obj_address = QUADS[IP][3];

					int obj_mem_sign = get_object_memory(obj_address)->signature;

					if (obj_mem_sign == -1 && arr_size == -1){
						cout << ">> Fatal Error: 'using as' employement exception; symbol is not instantiated" << endl;
						exit(EXIT_FAILURE);
					}

					if (obj_mem_sign != -1 && obj_mem_sign != class_sign){
						cout << ">> Fatal Error: 'using as' employement exception; symbol is instantiated as a different class type" << endl;
						exit(EXIT_FAILURE);
					}

					if (arr_size != -1){
						Memory* obj_mem;
						for (int i = 0; i < arr_size; i++){
							obj_mem = get_object_memory(obj_address + i);
							if (obj_mem->id == -1){
								// Here we must instantiate these array entrie with the appropriate class type
								write_to_memory(obj_address + i, to_string(class_sign));
							}
						}
					}

					IP++;
        }
        break;

			case OBJ_INST:
        {

					Memory* obj_mem;
					int obj_addr_is_ptr = QUADS[IP][1];
					int object_sign  = QUADS[IP][2];
					int obj_addr = QUADS[IP][3];

					if (obj_addr_is_ptr != -1) obj_addr = read_from_memory(obj_addr).i;

					obj_mem = get_object_memory(obj_addr);

					// Here we check to see if the object we are instatiating is not currently referenced bu the "this." operator
					// This prevents weird behaviour, e.g. changing an object's type in the middle of its own type's function execution
					if (THIS_MEM->id != -1 && obj_mem->id == THIS_MEM->id){
							cout << ">> Fatal Error: Cannot re-instantiate object variable within it's own scope" << endl;
							exit(EXIT_FAILURE);
					}

					write_to_memory(obj_addr, to_string(object_sign));

					IP++;
        }
        break;

			case OBJ_READ:
        {

					Memory* this_mem;
					Value result;

					int obj_addr = QUADS[IP][1];
					int object_var_addr = QUADS[IP][2];
					int result_addr = QUADS[IP][3];
					int ptr_value = -1;
					int obj_addr_is_ptr = -1;


					if (QUADS[IP].size() >= 5){
						ptr_value = QUADS[IP][4];
					}

					if (QUADS[IP].size() >= 6){
						obj_addr_is_ptr = QUADS[IP][5];
					}

					if (ptr_value == 1 || ptr_value == 3) object_var_addr = read_from_memory(object_var_addr).i;

					if (ptr_value == 2 || ptr_value == 3) result_addr = read_from_memory(result_addr).i;

					if (obj_addr != -1){
						if (obj_addr_is_ptr == -1) this_mem = get_object_memory(obj_addr);
						else this_mem = get_object_memory(read_from_memory(obj_addr).i);
					}
					else this_mem = THIS_MEM;

					result = read_from_memory(this_mem, object_var_addr);

					write_to_memory(result_addr, result.to_str());
					IP++;
        }
        break;

			case OBJ_WRITE:
        {

				 	Memory* this_mem;
					Value value;

					int obj_addr = QUADS[IP][1];
					int value_addr = QUADS[IP][2];
					int obj_var_addr = QUADS[IP][3];
					int ptr_value = -1;
					int obj_addr_is_ptr = -1;

					if (QUADS[IP].size() >= 5){
						ptr_value = QUADS[IP][4];
					}
					if (QUADS[IP].size() >= 6){
						obj_addr_is_ptr = QUADS[IP][5];
					}

					if (ptr_value == 1 || ptr_value == 3) value = read_from_memory(read_from_memory(value_addr).i);
					else value = read_from_memory(value_addr);

					if (ptr_value == 2 || ptr_value == 3) obj_var_addr = read_from_memory(obj_var_addr).i;

					if (obj_addr != -1){
						if (obj_addr_is_ptr == -1) this_mem = get_object_memory(obj_addr);
						else this_mem = get_object_memory(read_from_memory(obj_addr).i);
					}
					else this_mem = THIS_MEM;

					write_to_memory(this_mem, obj_var_addr, value.to_str());

					IP++;
        }
        break;

			case ERA:
				{
					int func_start_addr = QUADS[IP][3];
					if (MEMORY_STACK.size() > MEMORY_STACK_LIMIT){
						// Too many functions on the stack!
						cout << ">> Fatal Error: Memory Stack Limit of " << MEMORY_STACK_LIMIT << " reached (infinite recursion?) Terminating..." << endl;
						exit(EXIT_FAILURE);
					}

					MemoryContext new_memory_context = MemoryContext(FUNCTION_MEMORY_CONTEXT_SIGN.at(func_start_addr).at(0), FUNCTION_MEMORY_CONTEXT_SIGN.at(func_start_addr).at(1));
					new_memory_context.return_scope = (LOCAL_MEM->active) ? LOCAL_MEM : &GLOBAL_MEM;

					MEMORY_STACK.push(new_memory_context);
					IP++;
				}
				break;

			case PARAM:
				{

					Value param_value;

					int parent_obj_addr = QUADS[IP][1];
					int param_addr = QUADS[IP][3];

					if (parent_obj_addr != -1) param_value = read_from_memory(get_object_memory(parent_obj_addr), QUADS[IP][2]);
					else param_value = read_from_memory(QUADS[IP][2]);

					write_to_param(param_addr, param_value.to_str());
					IP++;
				}
				break;

			case GOSUB:
				{
					int func_start_addr = QUADS[IP][3];
					LOCAL_MEM = &(MEMORY_STACK.top());
					LOCAL_MEM->set_return_addr(IP + 1);

					IP = func_start_addr;
				}
				break;

			case OBJ_GOSUB:
				{

					int obj_addr_is_ptr = QUADS[IP][1];
					int object_addr = QUADS[IP][2];
					int func_start_addr = QUADS[IP][3];

					if (object_addr != -1){
						if (!OBJECT_MEMORY_STACK.size()){

							if (obj_addr_is_ptr == -1) OBJECT_MEMORY_STACK.push(get_object_memory(object_addr));
							else OBJECT_MEMORY_STACK.push(get_object_memory(read_from_memory(object_addr).i));

						}else{

							Memory* new_class_memory;

							if (obj_addr_is_ptr == -1) new_class_memory = get_object_memory(object_addr);
							else new_class_memory = get_object_memory(read_from_memory(object_addr).i);

							new_class_memory->return_memory = OBJECT_MEMORY_STACK.top();
							OBJECT_MEMORY_STACK.push(new_class_memory);
						}
						THIS_MEM = OBJECT_MEMORY_STACK.top();
					} else{
						THIS_OPERATOR_COUNTER++;
					}

					LOCAL_MEM = &(MEMORY_STACK.top());
					LOCAL_MEM->set_return_addr(IP + 1);

					IP = func_start_addr;
				}
				break;

			case READ:
				{

					int result_addr;
					int parent_obj_addr = QUADS[IP][1];
					int addr_is_ptr = QUADS[IP][2];

					if (addr_is_ptr == 1) result_addr = read_from_memory(QUADS[IP][3]).i;
					else result_addr = QUADS[IP][3];

					string user_input;
					getline(cin, user_input);

					if (parent_obj_addr != -1)  write_to_memory(get_object_memory(parent_obj_addr), result_addr, user_input);
					else write_to_memory(result_addr, user_input);

					IP++;
				}
				break;

			case PRNTBFFR:
				{
					Value printable = read_from_memory(QUADS[IP][3]);
					if (LOCAL_MEM->active) LOCAL_MEM->add_to_print_buffer(printable.to_str(true));
					else GLOBAL_MEM.add_to_print_buffer(printable.to_str(true));
					IP++;
				}
				break;

      case PRNT:
        {
          string printable = (LOCAL_MEM->active) ? LOCAL_MEM->flush_print_buffer() : GLOBAL_MEM.flush_print_buffer();
          cout << printable;
          IP++;
        }
        break;

			case PRNTLN:
        {
					string printable = (LOCAL_MEM->active) ? LOCAL_MEM->flush_print_buffer() : GLOBAL_MEM.flush_print_buffer();
					cout << printable << endl;
					IP++;
        }
        break;

			case STOX:
        {
					int parent_obj_addr = QUADS[IP][1];
					int result_addr = QUADS[IP][3];

					string stox_arg = read_from_memory(QUADS[IP][2]).s;

					write_to_memory(result_addr, stox_arg);

					IP++;
        }
        break;

			case SUBSTR:
        {
					int start_index = s_stoi(read_from_memory(QUADS[IP][2]).to_str());
					int size = s_stoi(read_from_memory(QUADS[IP][3]).to_str());
					int result_addr = QUADS[IP][4];

					string substr_arg = read_from_memory(QUADS[IP][1]).s;

					write_to_memory(result_addr, substr_arg.substr(start_index, size));

					IP++;
        }
        break;

			case STRLEN:
        {
					string string_arg = read_from_memory(QUADS[IP][2]).s;
					int result_addr = QUADS[IP][3];

					write_to_memory(result_addr, to_string(string_arg.length()));

					IP++;
        }
        break;

			case RANDINT:
        {
					int lower_bound = read_from_memory(QUADS[IP][1]).i;
					int upper_bound = read_from_memory(QUADS[IP][2]).i;
					int result_addr = QUADS[IP][3];

					int rand_num = rand() % (upper_bound - lower_bound + 1) + lower_bound; // Generate the number, assign to variable.

					write_to_memory(result_addr, to_string(rand_num));

					IP++;
        }
        break;

			case F_OPEN:
        {
					Memory* this_mem;
					int parent_obj_addr = QUADS[IP][1];
					int buffer_addr = QUADS[IP][4];
					int buffer_size = QUADS[IP][5];

					string file_path = read_from_memory(QUADS[IP][2]).s;
					string separator = read_from_memory(QUADS[IP][3]).s;

					if (parent_obj_addr > 0) this_mem = get_object_memory(parent_obj_addr);
					else if (parent_obj_addr == 0) this_mem = THIS_MEM;
					else this_mem = new Memory();

					vector<string> file_data = FileIO::parse_file(file_path, separator, buffer_size);

					for(int i = 0; i < file_data.size(); i++){
						if (this_mem->id != -1) write_to_memory(this_mem, buffer_addr + i, file_data[i]);
						else write_to_memory(buffer_addr + i, file_data[i]);
						if (file_data[i] == "END_OF_STREAM") break;
					}

					IP++;
        }
        break;

			case F_WRITE:
        {
					Memory* this_mem;
					int parent_obj_addr = QUADS[IP][1];
					int buffer_addr = QUADS[IP][4];
					int buffer_size = QUADS[IP][5];

					string file_path = read_from_memory(QUADS[IP][2]).s;
					string separator = read_from_memory(QUADS[IP][3]).s;

					if (parent_obj_addr > 0) this_mem = get_object_memory(parent_obj_addr);
					else if (parent_obj_addr == 0) this_mem = THIS_MEM;
					else this_mem = new Memory();

					vector<string> buffer;
					string next_entry;

					for(int i = 0; i < buffer_size; i++){
						if (this_mem->id != -1) next_entry = read_from_memory(this_mem, buffer_addr + i).to_str();
						else next_entry = read_from_memory(buffer_addr + i).to_str();
						if (next_entry == "END_OF_STREAM") break;
						buffer.push_back(next_entry);
					}

					FileIO::write_to_file(buffer, file_path, separator);

					IP++;
        }
        break;

      case GOTO:
        {
          int to_addr = QUADS[IP][3];
          IP = to_addr;
        }
        break;

			case GOTOF:
				{
					int to_addr = QUADS[IP][3];
					Value condition = read_from_memory(QUADS[IP][2]);
					Value false_value = Value(false);
					Value result = condition == false_value;
					if(result.b) IP = to_addr;
					else IP++;
				}
				break;

			case ENDFNC:
				{

					int was_class_func = QUADS[IP][3];
					int return_addr = LOCAL_MEM->return_addr;

					if (THIS_OPERATOR_COUNTER <= 0 && was_class_func){
						THIS_MEM = (OBJECT_MEMORY_STACK.size() > 1) ? OBJECT_MEMORY_STACK.top()->return_memory : new Memory();
						if (OBJECT_MEMORY_STACK.size()) OBJECT_MEMORY_STACK.pop();
					}else if (was_class_func) {
						THIS_OPERATOR_COUNTER--;
					}

					LOCAL_MEM = (MEMORY_STACK.size()) ? MEMORY_STACK.top().return_scope : new MemoryContext();
					if (MEMORY_STACK.size()) MEMORY_STACK.pop();

					IP = return_addr;
				}
				break;

      case END:
        {
          RUNNING = false;
        }
        break;

      default:
        {
        cout << ">> Fatal Error: Unknown Op: " << op << endl;
        exit(EXIT_FAILURE);
        }
    }
  }
}

int main () {

  // Setup virtual machine to run the program
  setup();

  // Run program
  run();

  return 0;
}
